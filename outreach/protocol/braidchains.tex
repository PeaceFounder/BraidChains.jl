\documentclass[12pt]{article}

\usepackage[margin=1in]{geometry} 
\usepackage{amsmath,amsthm,amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{cleveref}
 
\newenvironment{theorem}[2][Theorem]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{lemma}[2][Lemma]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{conjecture}[2][Conjecture]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{question}[2][Question]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{corollary}[2][Corollary]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{definition}[2][Definition]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}


\usepackage{enumitem}
\newlist{steps}{enumerate}{1}
\setlist[steps, 1]{label = {\bf step \arabic*}}


\begin{document}

% --------------------------------------------------------------
%                         Start here
% --------------------------------------------------------------

% \title{Pseudonym braiding and anonimity set} % replace with an appropriate title, choose something shortish & descriptive
\title{BraidChains: a legitimate anonimity through pseudonym braiding} % replace with an appropriate title, choose something shortish & descriptive
\author{Janis Erdmanis} % replace with your name, multiple authors go in alphabetical order by last name

\maketitle

\begin{definition}{(pseudonym)} 
A pseuodnym $p$ is a means to authetification for a particular {\bf owner} with an unique and public {\bf identifier}.
\end{definition}

\begin{definition}{(pseudonym equality)}
  Two pseudonyms are equal if equal are their identifiers.
\end{definition}

\begin{definition}{(pseudonym set)}
  $P$ is a set of all possible pseudonyms if there does not exist a pseudonym $q$ which is equal to any pseudonym $p \in P$.
\end{definition}

There is an almost infinite number of pseudonym systems possible. Let's list some to get an intuitive feel for definitions
\begin{itemize}
\item A signature or handwriting. In this case, the identifier is the slopes, the curves which can be identified to be unique and the owner is the one person which can reproduce the writing. 
\item A phone SIM card. A public identifier is a phone number, and the owner is the one person who can make calls, text messages with a corresponding phone number. In some cases, we take calls only from the known numbers, which shows that sometimes it is a means to authentication.
\item A computer connected to the internet. The public identifier, in this case, is IP address, and the owner is the user of the computer. If the computer is behind the router as is often the case, we may look that the pseudonym owner is the person who configures the router. Authentication we often experience in the way of tracking giving us personal suggestions or as a restriction to some content. 
\item Electronic signatures. In this case, the identifier is the public key (in some cases together with generator), and the owner is the private key holder. 
\end{itemize}
From examples, we shall exclude systems which use a secret token for the authentification as there is no public identifier which can be made public. Similarly, we shall exclude HMAC systems as there is no separation between owner and identifier. 

Some pseudonyms are safer than others. For example, an IP address can be somewhat easily forged by an adversary; a phone SIM card assumes a trustworthy phone service provider. On the contrary, electronic signatures similarly as their analogue counterparts do not need trustees and thus are unforgeable. 
\begin{definition}{(unforgeability)}
  A pseudonym $p \in P$ is unforgeable if only the owner can authenticate with the pseudonym $p$ identifier.
\end{definition}

In the definition, for a pseudonym, the owner as a person using the pseudonym is not linked publically. That is done with a purpose as we want to use a pseudonym to define anonymity. To make them as digital identities, we need to link the pseudonyms to their owners which is often done on the roster. 
\begin{definition}{(roster)}
  A roster $R \subset P$ is a subset of all pseudonyms where every pseudonym $r \in R$ owner is publically known.
\end{definition}

Most of the time when talking about anonymity, the probability theory can be used. To discuss the braiding protocol, we need to operate on the sets of pseudonyms. Besides, we will need to distinguish between absolute anonymity and a lack of membership to a particular group. Thus anonymity set is defined with respect to information which proves that one pseudonym is linked to a set of other pseudonyms and more information, for example, gained by an adversary can unlink and reduce the anonymity set size. This motivates the following definition.
\begin{definition}{(anonymity set)}
  A subset $A_S(p | I) \subset S \subset P$ of a pseudonym $p \in P$ in presence of {\bf information} $I$ is its anonymity set if the set $A_S(p | I)$ contains every pseudonym of $s \in S$ which is linked to a pseudonym $p$ owner.
\end{definition}


\begin{corollary}{I}
  If a pseudonym $p \in P$ is not linked to a subset $S \subset P$ for a given information $I$ the anonimity set is:
  \begin{equation}
    A_S(p | I) = \varnothing
  \end{equation}
\end{corollary}

\begin{definition}{(fairness)}
  A set $S \subset P$ is fair if for every pseuodnym $p \in S$ in presence of information $I$ the anonimity set is the pseudonym itself
  \begin{equation}
    A_S(p | I) = \{p\}
  \end{equation}
\end{definition}

\begin{definition}{(absolute anonimity)}
  The pseudonym $p \in P$ is absolutelly anonymous with resepect to a subset $S \subset P$ if its anonimity set is equal to the set $S$ itself
  \begin{equation}
    A_S(p|I) = S
  \end{equation}
\end{definition}

\section*{Braiding}

\begin{definition}{(member)}
  A pseudonym $p \in P$ is a member if it has access and can authenticate to a particular service.
\end{definition}

There are of course different kinds of services for which one can be considered a member. Here we shall always refer the member with respect to a braiding service which I will define shortly.

\begin{definition}{(state)}
  A state $S_T \subset P$ is a set of all members at a given moment $T \in N$.
\end{definition}


\begin{definition}{(braiding)}
  A state transition $S_T \to S_{T+1}$ is braiding if a subset of memebers $M \subset S_T$ generate a new set of pseudonyms $Q = S_{T+1} \cap (S_T \setminus M) $ in such a way that pseuodnym owners of $M$ map one to one to the speudonym owners in $Q$ while the anonimity set of every pseuodnym $q \in Q$
  \begin{equation}
    A_{S_T}(q|I) = M
  \end{equation}
\end{definition}

\begin{corollary}{II}
  The anonimity set of the new pseudonyms $q \in Q$ with respect to rooster $R \subset P$ after braiding is
  \begin{equation}
    A_R(q | I) = \bigcup_{m \in M} A_R(m|I) \label{eq:1}
  \end{equation}
\end{corollary}
This is an essential property for the braiding as it provides a possibility for exponential growth of anonymity set size with respect to a number of braidings a member participates.

\begin{definition}{(software-indpendance)}
  The braiding protocol is server-side software-independent for participant $m \in M \subset S_T$ if adversary controlling the braiding service and all other participants $M \setminus \{m\}$ can not exclude pseudonym $m$ owner in the state $S_{T+1}$.
\end{definition}

This property can be achieved, for example, if every participant after braiding $m \in M = S_T \setminus S_{T+1}$ must sign the resulting transaction $(S_T \setminus S_{T+1}, \, S_{T+1} \setminus S_T)$ before it is considered publically valid. In practice the signatures are used to obtain the pseudonym set $M$ for the transaction.

\begin{definition}{(braid)}
  A braid is a proposed state transaction $B = (S_T \setminus S_{T+1}, \, S_{T+1} \setminus S_T)$ formed during braiding at a given moment $T$.
\end{definition}

\begin{definition}{(optimal braid)}
  An optimal braid is a braid whose participants $m \in M = S_T \setminus S_{T+1}$ anonimity sets are pairwise exclusive
  \begin{equation}
    A_R(m_i|I) \cap A_R(m_j|I) = \varnothing.
  \end{equation}
\end{definition}

We can intuitively understand that if anonymity set size of every participant in the braid is small, then it is likely to be close to optimal. On the other limit, the anonymity sets get saturated, and its size for a participant before and after braiding would be about the same. This motivates us to introduce a gain associated with every member in a potential braid.

\begin{definition}{(gain)}
  A gain for a participant $m \in M = S_T \setminus S_{T+1}$ is an increase of anonimity set size making a state transition $S_T \to S_{T+1}$
  \begin{equation}
    {\rm gain}_T(m | I) = \left|\bigcup_{q \in M} A_R (q| I)  \setminus A_R(m | I) \right| 
  \end{equation}
\end{definition}

\begin{theorem}{(optimal gain)}
  For a fixed size optimal braids with a number of participants $N$, the anonimity set size after $L$ equal gain braidings for a single member $m \in S_T$ is
  \begin{equation}
    |A_R(m|I)|  = N^L
  \end{equation}

  {\bf Proof:} Lets consider the first braid of a member $m_1 \in S_1 = R$. In this case the anonimity set for each memeber $m$ consists of the member itself thus the anonimity size after first braiding is:
  \begin{equation}
    |A_R(m_1|I)| = N
  \end{equation}
  In the second step $m_2 \in S_2$ as braids are optimal the anonimity set size is:
  \begin{equation}
    |A_R(m_2|I)| = N |A_R(m_1|I)|
  \end{equation}
  the next step and so forth is the same $|A_R(m_{i+1}|I)| = N |A_R(m_i|I)|$ which proves the formula after substitution.
\end{theorem}

Using this theorem we can estimate the number of braidings each member ideally would need to perform until absolute anonymity $A_R(m|I) = R$ is reached:
\begin{equation}
  L = \log_N |R| \label{eq:2}
\end{equation}
This logarithmic dependence makes it feasible for gaining large anonymity set size in a reasonable number of interactions with external service while needing a small number of present participants to execute the protocol. That makes it feasible to run the braiding in the background which randomly selects time in which it interacts with the braiding service. A certified smart device would ensure that membership is not transferred to an adversary when malware is of concern.

\section*{Adversary}

We already excluded membership transfer as braiding is made software independent. The braiding should be reasonably robust as the number of participants in the braid can be made relatively small. Thus adversary would not be able to sabotage the braiding process by causing a significant impact either externally controlling the stability of the network connection or internally by pretending to have a network issue or received an incorrect braid and thus refusing to sign it. That, however, does not exclude adversary from learning identities of owners by controlling the braiding service (gatekeeper + mix) or by exclusion method knowing some owners of particular pseudonyms who participated in braiding with other members.

To model such a situation, we can consider that adversary has three sources of information
\begin{equation}
  I_A = I_{public} \cup I_{services} \cup I_{owners}
\end{equation}
$I_{public}$ is the information which is published for everyone to be able to audit the state transitions. As an example, those could be a participant signed braids. $I_{server}$ is the information which can be gained by exploiting the electronic voting protocol, for example, recording additional information in the gatekeeper and the mix. As well as gaining and exploiting the knowledge of traffic which I assumed to be inaccessible to an adversary when anonymization service such as TOR is used. And lastly, there is information on the pseudonym owners which adversary could have gained by having malware on the user's devices.

In contrast to gaining absolute anonymity set in one step, for braided anonymity, the information on the identity of the particular member is scrambled only between members who jointly participated in forming braids. In case for optimal gain braiding the number of participants, $W$ is:
\begin{equation}
  W = (N -1) \log_N |R|
\end{equation}
which is a fairly small number which adversary with the help of malware would need to control to learn who is the particular pseudonym owner. The difficulty for the adversary (unless the goal is to spy on one famous person) is the fact that each pseudonym has a different set of members between which the information is scrambled and thus major breaches of pseudonym identities are difficult.

Nevertheless, the adversary could attempt to game the system in a way that all participants except one are adversary controlled for every braid. On the other hand, the group manager does have the ability to enforce a policy on selecting who braids with whom. Thus a legitimate question rises on what approach the group manager needs to use to prevent the adversary from gaining useful information on other members.

One of the most effective policies seems to be not to allow to braid one member consecutively but require that between braids some $K$ members had braided in between. In this way, if adversary controls less than $K$ members, others remain anonymous for the adversary in spite of collected information. Another method could be to require that every participant from the braid makes about equal anonymity set size gains and thus excluding adversary as his controlled members would have a finite capacity to participate in a low gain braidings. 


\section*{Protocol overview}

In this section, we shall look into an implementation of a software-independent braiding protocol which shall allow obtaining close to absolute anonymity for every member. The first part of the protocol is the configuration of services, announcement their configuration on a public bulletin board and registration of members which can happen at any time of the braiding protocol â€” the person at the top hierarchy who does that we shall call guardian.

\begin{definition}{(guardian)}
  A guardian is a pseudonym who is on the top of the hierarchy to configure braiding and other services, announce their configuration on a public bulletin board and register new members to the sate $S_T$.
\end{definition}

The sate is an outcome of multiple member registrations and their braidings. To audit the protocol, we need to list the transactions in public and append-only bulletin board which contains member registrations issued by the guardian (or subordinate) and braids signed by involved participants.

\begin{definition}{(braidchain)}
  A braidchain is a public and append-only bulletin board which lists all legitimate transactions which are signed by involved pseudonyms. 
\end{definition}

In principle, it does not matter who writes the transactions in the braidchain as those upon added are audited. It is, however, much simpler if the guardian and its subordinates only have writing permissions to the braidchain whereas members and everyone else can only read it and audit.

The braiding protocol we will look into here is based on a simple mix based electronic voting system which is used to form a ballot from new member-generated pseudonym identifiers. To describe the protocol, we shall assume:
\begin{itemize}
\item The pseudonym of the mix and gatekeeper together with other configuration is made public bulletin board which is signed by the guardian;
\item The guardian registers and keeps registering new members to the braidchain and thus updates the state $S_T$ as braiding protocol proceeds or is repeated;
\item Each member has the correct guardian identifier to obtain the most recent correct configuration from the bulletin board;
\item Each member has an unlimited number of anonymous channels for sending and delivering messages. 
\end{itemize}
The last part is significant to prevent linking of newly generated pseudonyms with old ones by keeping track of the IP address used. In practice, a TOR could be used where a new circuit is generated for every single braiding. To simplify the description, we shall not mention details of the key exchange protocol, but say that pseudonym is simply validated, for example, as part of a Diffie-Hellman key exchange protocol which allows establishing a secure connection.

\subsection*{Authetification}

\begin{itemize}
\item The gatekeeper connects to the mix and validates that its pseudonym agrees with one specified in the bulletin board (signed by the guardian) and establishes a secure connection. 
\item A member $m \in S_T$ selects a random time and connects anonymously (through TOR) to the gatekeeper, validates its pseudonym and established a secure connection.
\item On the other end gatekeeper validates the pseudonym of the client to be in $S_T$, secures the connection and puts it in the waiting list.
\item When waiting list $W \subset S_T$ contains elements $M \subset W$ which satisfy a guardians specified {\bf condition} the braiding starts with those $M$ members.
\end{itemize}

The condition entails the number of participants required for a braid, a timeout period for the members who may have caused the previous braiding procedure to fail, and also a strategy which prevents for an adversary to use a small member coalition to unveil the gained anonymity as discussed in the previous section.

\subsection*{Braiding}

\begin{itemize}
\item Each member connects through the gatekeeper to the mix, validates its pseudonym to be in the guardian maintained bulletin board and establishes a secure connection.
\item Each member generates a pseudonym $q \in P$ in secret, stores its key (ownership) and sends the identifier to the mix.
\item On the other end the mix collects $|M|$ messages, sorts them and sends the resulting list back to the gatekeeper.
\item The gatekeeper receives the list, reinterprets that as a set of pseudonyms $Q \subset P$ and forms a braid.
\end{itemize}

As the braiding protocol did not produce any anonymity revealing information for external or internal parties as long as gatekeeper and mix do not collaborate, the anonymity set of each pseudonym in the list $q \in Q$ is $A_{S_T}(q|I) = M$. The last step is to confirm that the procedure was server-side software-independent to guarantee that no participant loses membership.

\subsection*{Authorization}

\begin{itemize}
\item The gatekeeper sends the braid to every participant $m \in M$.
\item Each participant $m \in M$ checks that his secretly generated pseudonym $q \subset P$ is listed in the braid $q \in Q$. If that is true makes the signature of the braid with $m$ and sends it back to the gatekeeper.
\item If braiding is successful, each member $m \in M$ delivers signature to the gatekeeper who forms a transaction and publishes that to braidchain. That officially announces the state change $S_T \to S_{T+1} = (S_T \setminus M) \cup Q$.
\item As the members synchronize with braidchain, the new braids are audited for a membership transfer of his owned pseudonyms $O \subset P$. An index is built locally for the state index $T_{grant}$ which grants membership for a pseudonym $o \in O$ and a state index $T_{trans}$ which transfers the membership. 
\end{itemize}

The result is that the member makes a secret map between the state number $T$ and his owned pseudonyms $o \in O$. The last granted pseudonym can be used again repeating the braiding procedure which enlarges anonymity set in every braid according to \cref{eq:1} which on average would require about a logarithmic number of braidings to get absolute anonymity with respect to a roster as evaluated in \cref{eq:2}. In practice, the member repeats the braiding protocol until a guardian specified anonymity set size threshold is reached, which then allows it to participate, for example, in voting.



\section*{Detailed protocol}


\subsection*{Agents}

The protocol has a different type of agents which we shall describe here and their role to the protocol:
\begin{itemize}
\item Guardian - an agent which sets up the system, anounces its parameters and maintains the services, for eample, checks that they are accessable from the interent. 
\item BraidChain - a guardian delegated agent which is responsable for adding valid member registration transactions from the guardian and adding valid transaction braids from the braider to the transaction log. Provides a service which hosts the transaction log and a service which provides certificates for a braid being added or not going to be added to the transaction log (see the step 7 under authorization). The data on the braidchain is used to calculate a state of the current memebers in the system $S_T \subset P$. 
\item World - anyone who is interested in observing the integrity of the braidchain by auditing the transactions and receivieng and dealing with complaints in the case of disputes.
\item Member - a person who owns the pseudonym whose identifier is listed in the current braidchain state $S_T$. The first pseudonym linked to the owners real identitiy is appoved by the guardian and submited to braidchain as registration transaction. In the braiding protocol the member participates in it with its keys of the pseudonyms which are created during execution of braiding protocol and stored locally in a $keychain$ a datastructure with a fixed API for signing messages with its stored keys. 
\item Braider - a guardian delegated agent which is repsonsible for sucesful execution of the braiding protocol. For sucesful operation the braider operates with multiple states
  \begin{itemize}
  \item $S_T$ a set of current memebers according to the braidchain.
  \item $HOLD \subset S_T$ a set of members which at a given moment are already taking part of the protocol and thus are not eligiable authetificate another time.
  \item $WaitingList$ a waiting list with a subset of memebers and their established symmetric keys for the session. 
  \item $Penalty$ a set of members and their penalties expressed in time for thoose which had caused the braiding protocol to fail.
  \end{itemize}
\item Mix - a generally trusted agent which provides honest mixing services without leaking mixing permuations to the braider. 
\end{itemize}

Each agent owns a secret key for the pseudonym identifier which is part of the system. To represent that we shall assume that a method $key(agent)$ is succesful if it is executed on the system which owns the key. 


\subsection*{Assumptions}

\begin{itemize}
\item The clocks of honest participants are synchronized and the correct time can be btained with $time()$.
\item Secure cryptographic primitives $hash$, $HMAC$, $sign$, $verify$, $randint$.
\item Client software is free from malware/spyware*. Breaking this assumption could end up losing the keys of the affected and would compromise the privacy of the individual;
\item The mixes uses the same cryptographic parameters as the systems using their services. This assumptions is neceessary to make the protocol as coincise as possible.
\item The pseudonym identifier is $G^p$ where $G$ is a generator and $p$ is a secret key. This assumption is necessary for the paricular mix protocol we shall be using.
\item IP address anonymizer allows unlinkable sessions (this excludes VPNs). The adversary shall not be able to infer that a person who at a given moment is using traffic anonymizer is using it to perform braiding for a given group. Breaking this assumption would allow adversary who spies on the network to do a corealation attacks and thus uncover the owners of the pseudonyms. 
\item The publically made information is scrutinized, the guardian is made accountable and if neceesary replaced by members on some previously agreed social contract. 
\end{itemize}

% Synchronized clcocks

\subsection*{Claimed properties}

For the system we have atwo set of gaols. One with respect to the mebers themselves and the other set is with repsect to the external observers who want to validate that the members do indeed achieve their goals during the braiding protocol and that the anonymized pseudonyms are indeed legitimate without trusitng any agent except the memebers themselves. 

Particularly for the memebrs there are two goals:
\begin{itemize}
\item Membership can't be lost to adversary during the execution of the braiding protocol even if adversary controls, writes code of every other agent in the system (except world). This property can be even achieved if the cleint hardware has malware as long as a certified device for pseuodonym gneration and braiding then by API it can be designed that keys never leaves the device. If that happens a proof against certifier is the device itself.
\item The anonymity set of newly generated pseudonyms are the union of anonumity sets of coresponding particpnats int the braid if either braider or mix is honest. In case adversary controls both the anonimity set before and after braiding with respect to adversary remains the same. 
\end{itemize}

In addition even an external observer from the publically available data can infer:
\begin{itemize}
\item That the current memeber pseudonyms are a product of the individuals in the rooster who had authorized the pseudonym changes by their previous memeber pseuodnyms. 
\item The memebership is not stolen by the adversary as long as a particular memeber is malware free, a fake pseudonyms added or an existing memeber removed without being explicit about it.
\item The anonimity set of each memeber pseudonym and its change uppon if adversary had controlled a particular mix or a set of members. Also evaluate the types of adversary which could have succesfully participated in the system to uncover the privacy of the members. 
\end{itemize}

Thus to sumarize theese goals the system we shall consider posseses a software independnace while provinding a strong privacy guarantees. It is fully accountable, transparent and privacy preserving.

\subsection*{Types}
\begin{itemize}
\item Contract
\item Braid
\item Transaction
\item KeyChain
\end{itemize}

\subsection*{Methods}

\begin{itemize}
\item $id(p)$ where $p$ is a pseudonym owner or a signature.
\item $key(p)$ returns a key if the command is executed on a system which owns the key
\item $||$ concatenites two objects into one
\item $sign(msg, key(p))$ issues a signature of the message with a pseudonym $id(p)$
\item $verify(msg, id(p))$ verifies a signature and returns ${1, 0}$ 
\item $rngint()$ returns a random integer
\item $HMAC(msg, key)$ returns authorization HMAC for a message for a key.
\item $A \to B: Msg$ An ordinary BAN notation
\item $A \overset{C}{\to} B: Msg$ a Msg which is transfered over an anonymous network with circuit $C$.
\item $newcircuit()$ generates a new circuit for anonymous messaging.
\item $sort(R)$ where $R \subset CryptoGroup$. Returns a sorted list of the gnerators in the set $R$.
\item $\left\{ MSG \right\}_K$. Sends a message which is HMAC authorized with a symmstric key $K$. In contrast to BAN usual notation there is no need for an encryption in the protocol.
\item $generate!(kc, Q) \to G^p, Q^p$ where $kc \in KeyChain$ and $Q \in CryptoGroup$. Generates a pseudonym with a key $p$ which si stored in the keychain $kc$ and returns a pseudonym identifier $G^p$ and its encryption $Q^p$. 
\item $braidset(W, B, P)$ where $W$ is a subset of memerbers $W \subset state(B)$, $P$ is a penalty list and $B$ is the braidchain. Returns a subset of $W$ or $\varnothing$ if the braidset is not sufficient.
\item $threshold(W, B)$ where $W$ is a subset of memerbers $W \subset state(B)$ and $B$ is a braidchain. A guardian specified algorithm which returns $1$ if the braiding prtocol can continue with a subset of memebers $W$.
\item $hash(bc)$ where $bc \in BraidChain$. Calcualtes and returns a hash of the ledger between the two latest braids inclusive.
\end{itemize}


\subsection*{Public buletin board}

For sucesful execution of the protocol every honest participant of the system needs to agree on a set of parameters and primitives used in the protocol. We shall assign guardian for this task which allows to narrow down to an immutable public buletin board which first contains:
\begin{itemize}
\item the cryptographic group $CryptoGroup$;
\item the generator $G \in CryptoGroup$ from the cyryptographic group which is used for asymeteric cryptography - Diffie-Hellman key exchange and electronic signatures;
\item sign and verify primitive specification;
\item identifier of the guardian $ID_{guardian} \in CryptoGroup$.
\end{itemize}
This allows the guradian to issue the right security parameters by making a on them signature. 

For instance we shall assume that the guardian hosts an entrance point to the system which provides its certified parameters for sucesful execution of the protocol which are:
\begin{itemize}
\item A timestamp of parameter distribution.
\item Identifier of the braider $ID_{braider}$
\item Identifier of the braidchain $ID_{braidchain}$
\item A set of pseudonym idetifiers for the mixes $MIXES_{ID}$
\item The IP address anonymizer, which is the same for a whoole group.
\item HMAC primitive specification. 
\item Timeout $T$ at which timestamped information is considered obselete (for simplicity I assume that it is the same for each step of the protocol).
\item Netwoerk address of the braider, braidchain and mixes on the internet
\end{itemize}
All this specification is signed by guardian which thus can be made accountable, for any change made. In addition one may add a application specific parameters, for example, specifically for the voting and etc.







\subsection*{Authetification}


\begin{steps}
\item $(Member \to Braider)$ Member generates a random integer $a \leftarrow {\rm rngint}()$, calculates $A \leftarrow G^a$, sets timestamp $t_a \leftarrow {\rm time}()$, isues a signature with a member pseudonym $m \in S_T$ with keychain $s_a \leftarrow {\rm sign}(A || t_a, {\rm id}(m), kc)$. Generates a circuit for anonymous messaging $C \leftarrow {\rm newcircuit}()$ and sends a following message through the circuit to the braider:
  \begin{equation}
    Member \overset{C}{\to} Braider: A, t_a, s_a  
  \end{equation}

\item $(Braider \to Member)$ Checks that $|t_a - {\rm time}()| < T$, ${\rm id}(s_a) \in S_T \setminus H$, ${\rm verify}(A||t_a,s_a) = 1$. Generates a random integer $b \leftarrow {\rm rngint}()$, calculates $B \leftarrow G^b$, sets timestamp $t_b \leftarrow {\rm time}()$, issues a signature $s_b \leftarrow  {\rm sign}(B || t_b, {\rm key}(braider))$. Derives a symmetric key $K_{ab} \leftarrow A^b$, calculates a hmac $h_{ba} \leftarrow {\rm HMAC}(B||A,K_{ab})$. Sends a following message to the member:
  \begin{equation}
    Braider \overset{C}{\to} Member: B, t_b, s_b, h_{ba}
  \end{equation}

\item $(Member \to Braider)$ Checks that $|t_b - {\rm time}()| < T$, ${\rm id}(s_b)={\rm id}(braider),$ ${\rm verify}(B||t_b,s_b)=1$. Derives a symmetric key $K_{ab} \leftarrow B^a$ and checks the recieved hmac $h_{ba} = {\rm HMAC}(B||A,K_{ab})$. Calculates a hmac $h_{ba} \leftarrow {\rm HMAC}(A||B,K_{ab})$ and sends a following message to the braider:
  \begin{equation}
    Member \overset{C}{\to} Braider: h_{ab}
  \end{equation}

\item $(Braider)$ Cheks that $h_{ab} = {\rm HMAC}(A||B, K_{ab})$. Adds the connection to the waiting list $W_{T+1} \to W_T \cup \left\{ ({\rm id}(s_a), K_{ab}) \right\}$ and pseudonym identifier to the holad $H_{T+1} \to H_T \cup \{ {\rm id}(s_a)\}$. Calculates a braid set from the members in the waiting list $B_{set} \leftarrow {\rm braidset}(W, S_T, P)$. If $B_{set}\not\subset \varnothing$ the braider proceeds to the braiding part. Otherwise waits for another memeber to join.
\end{steps}

\subsection*{Braiding}

\begin{steps}
\item $(Mix \to Braider)$ Generates a random integer $q \leftarrow {\rm rngint}()$, calculates $Q \leftarrow G^q$, sets a timestamp $t_q \leftarrow {\rm time}()$ and issues a signature $s_q \leftarrow {\rm sign}(Q||t_q, {\rm key}(mix))$. Sends a following message to the braider:
  \begin{equation}
    Mix \to Braider: Q, t_q, s_q
  \end{equation}
\item $(Braider \to Mix)$ Checks that $|t_q - {\rm time}()|<T$, ${\rm id}(s_q)={\rm id}(mix)$, ${\rm verify}(Q||t_q, s_q) = 1$. Generates a random integer $d \leftarrow {\rm rngint}()$, calculates $D \leftarrow G^d$ and derives a common key $K_{qd} = Q^d$. Calculates hmac $h_{dq} \leftarrow {\rm HMAC}(D||Q,K_{dq})$ and sends a following message to the mix:
  \begin{equation}
    Braider \to Mix: D, h_{dq}
  \end{equation}
\item $(Mix \to Braider)$ Derives a key $K_{dq}=D^q$ and checks the received hmac $h_{dq} = {\rm HMAC}(D||Q,K_{dq})$. Calculates hmac $h_{qd} \leftarrow {\rm HMAC}(Q||D,K_{dq})$ and sends that to the braider:
  \begin{equation}
    Mix \to Braider: h_{qd}
  \end{equation}
\item $(Braider \overset{C}{\to} \forall B_{set})$ Checks received hamc $h_qd = {\rm HMAC}(Q||D,K_{dq})$. Forwards to every participant of $B_{set}$ parameters received from the mix:
  \begin{equation}
    Braider \overset{C}{\to} \forall B_{set}: \left\{ Q, t_q, s_q \right\}_{K_{ab}}
  \end{equation}
  
\item $(\forall B_{set} \to Braider)$ Checks that $|t_q - {\rm time}()|<T$, ${\rm id}(s_q)={\rm id}(mix)$, ${\rm verify}(Q||t_q, s_q) = 1$. Gnereates a new pseudonym $P,X \leftarrow G^p, Q^p \leftarrow {\rm generate!}(kc, Q)$. Sends the encryption $X$ to the braider:
  \begin{equation}
    \forall B_{set} \overset{C}{\to} Braider: \left\{ X \right\}_{K_{ab}}
  \end{equation}
  
\item $(Braider \to Mix)$ Receives a set pseudonym identifier encryptions $\left\{ X_k \right\}$ from $B^*_{set} \subset B_{set}$. If ${\rm threshold}(B^*_{set})=1$ is satisfied the braiding protocol continues with $B^*_{set}$. Forms a secret ballot by sorting the pseuodnym encryptions $SecretBallot \leftarrow {\rm sort}(\left\{ X_k \right\})$ and sends that to the mix:
  \begin{equation}
    Braider \to Mix: \left\{ SecretBallot  \right\}_{K_{dq}}
  \end{equation}

\item $(Mix \to Braider)$ For each encryption $X_k \in SecretBallot$ calculates a coresponding pseuodnym $P_k \leftarrow X_k^{N - q}$ where $N$ is the order of the group $G$. Forms a ballot $Ballot \leftarrow {\rm sort}(P_k)$ and sends it back to to the braider:
  \begin{equation}
    Mix \to Braider: \left\{ Ballot \right\}_{K_{dq}}
  \end{equation}
  
\end{steps}

\subsection*{Authorization}

\begin{steps}
\item $(Braider \to \forall B^*_{set})$ Calculates the hash of the braidchain $H_{BC} \leftarrow {\rm hash}(braidchain)$, sets a timestamp $t_{br} \leftarrow {\rm time}()$, and foms a $braid \leftarrow (H_{BC}, t_{br}, ID_{mix}, Ballot)$. Sends that to each paticipant from the $B^*_{set}$:
  \begin{equation}
    Braider \overset{C}{\to} \forall B^*_{set}: \left\{ H_{BC}, ID_{mix}, t_{br}, Ballot \right\}_{K_{ab}}
  \end{equation}
\item $(\forall B^*_{set} \to Braider)$ Checks that ${\rm id}(mix) = ID_{mix}$, $|t_{br} - {\rm time}()|<T$ and that $P \in Ballot$. Issues a signature of the braid $s_{braid} \leftarrow {\rm sign}("BRAID"||braid, {\rm id}(m), kc)$. Sends the signature to the braider:
  \begin{equation}
    \forall B^*_{set} \overset{C}{\to} Braider : \left\{ s_{braid} \right\}_{K_{ab}}
  \end{equation}

\item $(Braider \to BraidChain)$ Checks that ${\rm id}(s_{braid})={\rm id}(s_A)$, ${\rm verify}("BRAID"|| braid, s_{braid})=1$. Recieves a valid $s_{braid}$ from every $B^{**}_{set} \subset B^*_{set}$. If succesful $B^{**}_{set} = B^{*}_{set}$ and a contract is formed from all received signatures $contract \leftarrow \left\{ s^k_{braid} \right\}$ else $B^{*}_{set} \setminus B^{**}$ are added to the penalty list $Penalty$. Submits the braid transaction to the braidchain:
  \begin{equation}
    Braider \to BraidChain: braid, contract
  \end{equation}

\item $(BraidChain \to World)$ If transaction is valid (see section on BraidChain) the transaction is appended to the braidchain which authorizes a state transition $S_{T+1} \to (S_T \setminus B^*_{set}) \cup Ballot$. Distributes new transactions to the world which audits them.  %Returns the $row$ at which the transaction is recorded on the braidchain together with a signature issued by braider $s_{braider} \leftarrow {\rm sign}(row||contract, {\rm key}(braider))$:
  % \begin{equation}
  %   Braider \to \forall B^*_{set}: \left\{row, contract, s_{bc} \right\}_{K_{ab}}
  % \end{equation}


\item $(\forall B^*_{set} \to BraidChain)$ Waits until $t_{br} + 2T < {\rm time}()$. Asks for to the braidchain master whether $braid$ is recorded:
  \begin{equation}
    \forall B^*_{set} \overset{C}{\to} BraidChain: braid
  \end{equation}
  

\item $(BraidChain \overset{C}{\to} \forall B^*_{set})$ Sets time $t_{query} \leftarrow {\rm time}()$. Looks into the list of transactions and if $braid$ is part of the list sets a $row \leftarrow K$ else sets it $row \leftarrow 0$. Forms a signature $s_{bc} \leftarrow {\rm sign}(t_{query}||row||braid,{\rm key}(braidchain))$ and sends a following message to the participants from $B^*_{set}$.
  \begin{equation}
    BraidChain \overset{C}{\to} \forall B^*_{set}: t_{query}, row, s_{bc}
  \end{equation}
  
\item $(\forall B^*_{set})$ Checks that $t_{br} + 2T < t_{query} < {\rm time}()$, ${\rm id}(s_{bc}) = {\rm id}(braidchain)$, and \\ $verify(t_{query}||row||braid, s_{bc})=1$. Stores $(t_{query}, row, braid, s_{bc})$ locally as a proof against the guardian in case of a conflict. If $row>0$ updates the local $index$ at which pseudonym $m$ memebership is transfered to a pseudonym $P$.
  
\end{steps}




\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
